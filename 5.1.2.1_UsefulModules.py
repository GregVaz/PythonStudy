# dir() function

'''
it is able to reveal all the names provided through a particular module.

The function returns an alphabetically sorted list containing all entities' names available in the module identified by a name passed to the function as an argument:
dir(module)

Note: if the module's name has been aliased, you must use the alias, not the original name.

For example, you can run the following code to print the names of all entities within the math module:
'''
import math

for name in dir(math):
    print(name, end="\t")

'''
Have you noticed these strange names beginning with __ at the top of the list? We'll tell you more about them when we talk about the issues related to writing your own modules.
Using the dir() function inside a code may not seem very useful - usually you want to know a particular module's contents before you write and run the code.

Fortunately, you can execute the function directly in the Python console (IDLE), without needing to write and run a separate script.
'''

'''
Selected functions from the math module

Let's start with a quick preview of some of the functions provided by the math module.
The first group of the math's functions are connected with trigonometry:

    sin(x) → the sine of x;
    cos(x) → the cosine of x;
    tan(x) → the tangent of x.

    asin(x) → the arcsine of x;
    acos(x) → the arccosine of x;
    atan(x) → the arctangent of x.

    pi → a constant with a value that is an approximation of π;
    radians(x) → a function that converts x from degrees to radians;
    degrees(x) → acting in the other direction (from radians to degrees)

    sinh(x) → the hyperbolic sine;
    cosh(x) → the hyperbolic cosine;
    tanh(x) → the hyperbolic tangent;
    asinh(x) → the hyperbolic arcsine;
    acosh(x) → the hyperbolic arccosine;
    atanh(x) → the hyperbolic arctangent.

Another group of the math's functions is formed by functions which are connected with exponentiation:

    e → a constant with a value that is an approximation of Euler's number (e)
    exp(x) → finding the value of ex;
    log(x) → the natural logarithm of x
    log(x, b) → the logarithm of x to base b
    log10(x) → the decimal logarithm of x (more precise than log(x, 10))
    log2(x) → the binary logarithm of x (more precise than log(x, 2))
    pow(x, y) → finding the value of xy (mind the domains) 

The last group consists of some general-purpose functions like:

    ceil(x) → the ceiling of x (the smallest integer greater than or equal to x)
    floor(x) → the floor of x (the largest integer less than or equal to x)
    trunc(x) → the value of x truncated to an integer (be careful - it's not an equivalent either of ceil or floor)
    factorial(x) → returns x! (x has to be an integral and not a negative)
    hypot(x, y) → returns the length of the hypotenuse of a right-angle triangle with the leg lengths equal 
    to x and y (the same as sqrt(pow(x, 2) + pow(y, 2)) but more precise)

'''

# random module
'''
It delivers some mechanisms allowing you to operate with pseudorandom numbers.

Note the prefix pseudo - the numbers generated by the modules may look random in the sense that you cannot predict 
their subsequent values, but don't forget that they all are calculated using very refined algorithms.
Two dice - the concept of random

The algorithms aren't random - they are deterministic and predictable. Only those physical processes which run 
completely out of our control (like the intensity of cosmic radiation) may be used as a source of actual random data. 
Data produced by deterministic computers cannot be random in any way.

A random number generator takes a value called a seed, treats it as an input value, calculates a "random" number based on it (the method depends 
on a chosen algorithm) and produces a new seed value.

The length of a cycle in which all seed values are unique may be very long, but it isn't infinite - sooner or later the seed values will start 
repeating, and the generating values will repeat, too. This is normal. It's a feature, not a mistake, or a bug.

The initial seed value, set during the program start, determines the order in which the generated values will appear.
'''

# The most general function named random() (not to be confused with the module's name) produces a float number x coming from the range (0.0, 1.0) - in other words: (0.0 <= x < 1.0).
from random import random

for i in range(5):
    print(random())

# The seed() function is able to directly set the generator's seed. We'll show you two of its variants:
#    seed() - sets the seed with the current time;
#    seed(int_value) - sets the seed with the integer value int_value.

from random import seed

seed(0)

for i in range(5):
    print(random())


'''
If you want integer random values, one of the following functions would fit better:

    randrange(end)
    randrange(beg, end)
    randrange(beg, end, step)
    randint(left, right)

The first three invocations will generate an integer taken (pseudorandomly) from the range (respectively):

    range(end)
    range(beg, end)
    range(beg, end, step)

Note the implicit right-sided exclusion!

The last function is an equivalent of randrange(left, right+1) - it generates the integer value i, which falls in the range [left, right] (no exclusion on the right side).
'''

from random import randrange, randint

print(randrange(1), end=' ')
print(randrange(0, 1), end=' ')
print(randrange(0, 1, 1), end=' ')
print(randint(0, 1))


for i in range(10):
    print(randint(1, 10), end=',')

'''
The previous functions have one important disadvantage - they may produce repeating values even 
if the number of subsequent invocations is not greater than the width of the specified range.

As you can see, this is not a good tool for generating numbers in a lottery. Fortunately, there is a better solution than writing your own code to check 
the uniqueness of the "drawn" numbers.

It's a function named in a very suggestive way - choice:

    choice(sequence)
    sample(sequence, elements_to_choose=1)

The first variant chooses a "random" element from the input sequence and returns it.

The second one builds a list (a sample) consisting of the elements_to_choose element (which defaults to 1) "drawn" from the input sequence.

In other words, the function chooses some of the input elements, returning a list with the choice. The elements in the sample are placed in 
random order. Note: the elements_to_choose must not be greater than the length of the input sequence.
'''


from random import choice, sample

lst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

print(choice(lst))
print(sample(lst, 5))
print(sample(lst, 10))


# platform module

'''
The platform module lets you access the underlying platform's data, i.e., hardware, operating system, and interpreter version information.

There is a function that can show you all the underlying layers in one glance, named platform, too. It just returns a string describing 
the environment; thus, its output is rather addressed to humans than to automated processing (you'll see it soon).

This is how you can invoke it: platform(aliased = False, terse = False)

And now:

    aliased → when set to True (or any non-zero value) it may cause the function to present the alternative underlying layer names 
    instead of the common ones;
    terse → when set to True (or any non-zero value) it may convince the function to present a briefer form of the result (if possible)


If you need to know what version of Python is running your code, you can check it using a number of dedicated functions - here are two of them:

    python_implementation() → returns a string denoting the Python implementation (expect CPython here, unless you decide to use any non-canonical Python branch)
    python_version_tuple() → returns a three-element tuple filled with:
        the major part of Python's version;
        the minor part;
        the patch level number.

'''


from platform import platform, machine, processor, system, version, python_implementation, python_version_tuple

print(platform())
print(machine()) # you may just want to know the generic name of the processor which runs your OS together with Python and your code - a function named machine() will tell you that
print(processor()) # The processor() function returns a string filled with the real processor name (if possible).
print(system()) # A function named system() returns the generic OS name as a string.
print(version()) # The OS version is provided as a string by the version() function.

print(python_implementation())

for atr in python_version_tuple():
    print(atr)